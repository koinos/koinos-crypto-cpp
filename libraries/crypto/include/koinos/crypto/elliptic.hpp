#pragma once
#include <koinos/pack/rt/basetypes.hpp>
#include <koinos/exception.hpp>

#include <secp256k1.h>

namespace koinos::crypto {

   using recoverable_signature = fixed_blob< 65 >;                         ///< A 65 byte recoverable ECDSA siganture
   using public_key_data       = fixed_blob< sizeof( secp256k1_pubkey ) >; ///< The full non-compressed ECDSA public key point
   using compressed_public_key = fixed_blob< 33 >;                         ///< The 33 byte compressed ECDSA public key
   using private_key_secret    = fixed_blob< 32 >;                         ///< The 32 byte ECDSA prvate key secret

   KOINOS_DECLARE_EXCEPTION( key_serialization_error );
   KOINOS_DECLARE_EXCEPTION( key_recovery_error );
   KOINOS_DECLARE_EXCEPTION( key_manipulation_error );
   KOINOS_DECLARE_EXCEPTION( signing_error );

   /**
    *  @class public_key
    *  @brief contains only the public point of an elliptic curve key.
    *
    *  This is a wrapper around a 64 byte ECDSA public key and to interface with secp256k functions.
    *  Internally, they key is 64 bytes, but when serialized it is a 33 byte compressed public key.
    */
   class public_key
   {
      public:
         public_key();
         public_key( const public_key& k );
         public_key( public_key&& pk );

         ~public_key();

         compressed_public_key serialize()const;
         static public_key deserialize( const compressed_public_key& cpk );

         operator compressed_public_key()const { return serialize(); }

         /**
          * Recovers a public key from a 65 byte recoverable signature (R, S, rec_id).
          * The signature must be in the "canonical" format where S < N/2 mod N.
          * Signatures generated by this library are guaranteed to be canonical, but
          * canonicity needs to be checked nonetheless.
          *
          * @param sig A 65 byte recoverable signature
          * @param digest The sha256 digest that was signed
          *
          * @throw koinos_exception a public key could not be recovered from the signature
          */
         static public_key recover( const recoverable_signature& sig, const multihash& digest );

         /** Computes new pubkey = regenerate(offset).pubkey + old pubkey
         *                      = offset * G + 1 * old pubkey ?! */
         public_key add( const multihash& offset )const;

         bool valid()const;

         public_key& operator =( public_key&& pk );
         public_key& operator =( const public_key& pk );

         inline friend bool operator ==( const public_key& a, const public_key& b )
         {
            return std::memcmp( a._key.data(), b._key.data(), sizeof(public_key_data) ) == 0;
         }

         inline friend bool operator !=( const public_key& a, const public_key& b )
         {
            return !(a == b);
         }

         // Allows to convert current public key object into base58 number.
         std::string to_base58() const;
         static std::string to_base58( const compressed_public_key &key );
         static public_key from_base58( const std::string& b58 );

         std::string to_address( uint8_t prefix = 0x00 ) const;

         unsigned int fingerprint() const;

         static bool is_canonical( const recoverable_signature& c );

      private:
         friend class private_key;
         static public_key from_key_data( const public_key_data& v );

         public_key_data _key;
   };

   /**
    *  @class private_key
    *  @brief an elliptic curve private key.
    *
    *  This is a wrapper around a 64 byte ECDSA
    */
   class private_key
   {
      public:
         private_key();
         private_key( private_key&& pk );
         private_key( const private_key& pk );
         ~private_key();

         private_key& operator=( private_key&& pk );
         private_key& operator=( const private_key& pk );

         static private_key regenerate( const multihash& secret );

         /**
         *  This method of generation enables creating a new private key in a deterministic manner relative to
         *  an initial seed.   A public_key created from the seed can be multiplied by the offset to calculate
         *  the new public key without having to know the private key.
         */
         static private_key generate_from_seed( const multihash& seed, const multihash& offset = multihash() );

         private_key_secret get_secret()const; // get the private key secret

         operator private_key_secret ()const { return get_secret(); }

         recoverable_signature sign_compact( const multihash& digest )const;

         public_key get_public_key()const;

         inline friend bool operator==( const private_key& a, const private_key& b )
         {
            return std::memcmp( a.get_secret().data(), b.get_secret().data(), 32 ) == 0;
         }

         inline friend bool operator!=( const private_key& a, const private_key& b )
         {
            return !(a == b);
         }

         inline friend bool operator<( const private_key& a, const private_key& b )
         {
            return std::memcmp( a.get_secret().data(), b.get_secret().data(), 32 ) < 0;
         }

         unsigned int fingerprint() const { return get_public_key().fingerprint(); }

         std::string to_wif( uint8_t prefix = 0x80 );
         static private_key from_wif( const std::string& b58, uint8_t prefix = 0x80 );

      private:
         private_key_secret _key;
   };

} // koinos::crypto
